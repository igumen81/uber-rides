const assert = require("node:assert");

const suites = [];
const suiteStack = [];

function currentSuite() {
  return suiteStack[suiteStack.length - 1];
}

function describe(name, fn) {
  const suite = { name, tests: [] };
  suites.push(suite);
  suiteStack.push(suite);
  try {
    const result = fn();
    if (result && typeof result.then === "function") {
      throw new Error("Async describe functions are not supported in this stub");
    }
  } finally {
    suiteStack.pop();
  }
}

function it(name, fn) {
  const suite = currentSuite();
  if (!suite) {
    throw new Error("it() must be called within describe()");
  }
  suite.tests.push({ name, fn });
}

const test = (name, fn) => it(name, fn);

function checkNumber(value, matcherName) {
  if (typeof value !== "number" || Number.isNaN(value)) {
    throw new TypeError(`${matcherName} expects a numeric value`);
  }
}

function expect(received) {
  return {
    toBe(expected) {
      assert.strictEqual(received, expected);
    },
    toEqual(expected) {
      assert.deepStrictEqual(received, expected);
    },
    toBeCloseTo(expected, precision = 2) {
      checkNumber(received, "toBeCloseTo");
      checkNumber(expected, "toBeCloseTo");
      const tolerance = Math.pow(10, -precision) / 2;
      if (Math.abs(received - expected) > tolerance) {
        throw new assert.AssertionError({
          message: `Expected ${received} to be close to ${expected} with precision ${precision}`,
          actual: received,
          expected,
          operator: "toBeCloseTo",
        });
      }
    },
    toBeGreaterThan(expected) {
      checkNumber(received, "toBeGreaterThan");
      checkNumber(expected, "toBeGreaterThan");
      if (!(received > expected)) {
        throw new assert.AssertionError({
          message: `Expected ${received} to be greater than ${expected}`,
          actual: received,
          expected,
          operator: ">",
        });
      }
    },
    toBeGreaterThanOrEqual(expected) {
      checkNumber(received, "toBeGreaterThanOrEqual");
      checkNumber(expected, "toBeGreaterThanOrEqual");
      if (!(received >= expected)) {
        throw new assert.AssertionError({
          message: `Expected ${received} to be ≥ ${expected}`,
          actual: received,
          expected,
          operator: ">=",
        });
      }
    },
    toBeLessThan(expected) {
      checkNumber(received, "toBeLessThan");
      checkNumber(expected, "toBeLessThan");
      if (!(received < expected)) {
        throw new assert.AssertionError({
          message: `Expected ${received} to be less than ${expected}`,
          actual: received,
          expected,
          operator: "<",
        });
      }
    },
    toBeLessThanOrEqual(expected) {
      checkNumber(received, "toBeLessThanOrEqual");
      checkNumber(expected, "toBeLessThanOrEqual");
      if (!(received <= expected)) {
        throw new assert.AssertionError({
          message: `Expected ${received} to be ≤ ${expected}`,
          actual: received,
          expected,
          operator: "<=",
        });
      }
    },
  };
}

async function runSuites() {
  let failed = 0;
  let executed = 0;
  for (const suite of suites) {
    console.log(`\n${suite.name}`);
    for (const testCase of suite.tests) {
      try {
        const result = testCase.fn();
        if (result && typeof result.then === "function") {
          await result;
        }
        console.log(`  ✓ ${testCase.name}`);
      } catch (error) {
        failed += 1;
        console.log(`  ✗ ${testCase.name}`);
        console.error(error instanceof Error ? error.stack : error);
      }
      executed += 1;
    }
  }

  if (executed === 0) {
    console.warn("No tests were executed.");
  } else if (failed === 0) {
    console.log(`\nAll ${executed} test(s) passed.`);
  } else {
    console.error(`\n${failed} test(s) failed.`);
    process.exitCode = 1;
  }
}

function resetSuites() {
  suites.length = 0;
  suiteStack.length = 0;
}

module.exports = {
  describe,
  it,
  test,
  expect,
  runSuites,
  resetSuites,
};
